// This file is @generated by prost-build.
/// Main message type that wraps all possible message variants
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Message {
  #[prost(oneof = "message::Payload", tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10")]
  pub payload: ::core::option::Option<message::Payload>,
}
/// Nested message and enum types in `Message`.
pub mod message {
  #[derive(Clone, PartialEq, ::prost::Oneof)]
  pub enum Payload {
    #[prost(message, tag = "1")]
    Ping(super::Ping),
    #[prost(message, tag = "2")]
    IndirectPing(super::IndirectPing),
    #[prost(message, tag = "3")]
    Ack(super::Ack),
    #[prost(message, tag = "4")]
    Suspect(super::Suspect),
    #[prost(message, tag = "5")]
    Alive(super::Alive),
    #[prost(message, tag = "6")]
    Dead(super::Dead),
    #[prost(message, tag = "7")]
    PushPull(super::PushPull),
    #[prost(bytes, tag = "8")]
    UserData(::prost::bytes::Bytes),
    #[prost(message, tag = "9")]
    Nack(super::Nack),
    #[prost(message, tag = "10")]
    ErrorResponse(super::ErrorResponse),
  }
}
/// Node represents a member in the cluster
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Node {
  #[prost(bytes = "bytes", tag = "1")]
  pub id: ::prost::bytes::Bytes,
  #[prost(bytes = "bytes", tag = "2")]
  pub address: ::prost::bytes::Bytes,
}
/// PushNodeState represents the state of a node that is pushed to remote servers
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PushNodeState {
  #[prost(bytes = "bytes", tag = "1")]
  pub id: ::prost::bytes::Bytes,
  #[prost(bytes = "bytes", tag = "2")]
  pub address: ::prost::bytes::Bytes,
  #[prost(message, optional, tag = "3")]
  pub meta: ::core::option::Option<Meta>,
  #[prost(uint32, tag = "4")]
  pub incarnation: u32,
  #[prost(enumeration = "State", tag = "5")]
  pub state: i32,
  #[prost(uint32, tag = "6")]
  pub protocol_version: u32,
  #[prost(uint32, tag = "7")]
  pub delegate_version: u32,
}
/// Meta contains delegate metadata
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Meta {
  #[prost(bytes = "bytes", tag = "1")]
  pub data: ::prost::bytes::Bytes,
}
/// Ack response for a ping
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Ack {
  #[prost(uint32, tag = "1")]
  pub sequence_number: u32,
  #[prost(bytes = "bytes", tag = "2")]
  pub payload: ::prost::bytes::Bytes,
}
/// Nack response for failed indirect pings
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Nack {
  #[prost(uint32, tag = "1")]
  pub sequence_number: u32,
}
/// Error response from remote peer
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ErrorResponse {
  #[prost(string, tag = "1")]
  pub message: ::prost::alloc::string::String,
}
/// Alive message indicating a node is alive
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Alive {
  #[prost(uint32, tag = "1")]
  pub incarnation: u32,
  #[prost(message, optional, tag = "2")]
  pub meta: ::core::option::Option<Meta>,
  #[prost(message, optional, tag = "3")]
  pub node: ::core::option::Option<Node>,
  #[prost(uint32, tag = "4")]
  pub protocol_version: u32,
  #[prost(uint32, tag = "5")]
  pub delegate_version: u32,
}
/// Dead message indicating a node is considered dead
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Dead {
  #[prost(uint32, tag = "1")]
  pub incarnation: u32,
  #[prost(bytes = "bytes", tag = "2")]
  pub node_id: ::prost::bytes::Bytes,
  #[prost(bytes = "bytes", tag = "3")]
  pub from_id: ::prost::bytes::Bytes,
}
/// Suspect message indicating a node is suspected to be down
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Suspect {
  #[prost(uint32, tag = "1")]
  pub incarnation: u32,
  #[prost(bytes = "bytes", tag = "2")]
  pub node_id: ::prost::bytes::Bytes,
  #[prost(bytes = "bytes", tag = "3")]
  pub from_id: ::prost::bytes::Bytes,
}
/// PushPull message for state synchronization
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PushPull {
  #[prost(bool, tag = "1")]
  pub join: bool,
  #[prost(message, repeated, tag = "2")]
  pub states: ::prost::alloc::vec::Vec<PushNodeState>,
  #[prost(bytes = "bytes", tag = "3")]
  pub user_data: ::prost::bytes::Bytes,
}
/// Ping message to check node liveness
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Ping {
  #[prost(uint32, tag = "1")]
  pub sequence_number: u32,
  #[prost(message, optional, tag = "2")]
  pub node: ::core::option::Option<Node>,
}
/// IndirectPing message for checking node liveness through an intermediary
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IndirectPing {
  #[prost(uint32, tag = "1")]
  pub sequence_number: u32,
  #[prost(message, optional, tag = "2")]
  pub source_node: ::core::option::Option<Node>,
  #[prost(message, optional, tag = "3")]
  pub target_node: ::core::option::Option<Node>,
  #[prost(message, optional, tag = "4")]
  pub relay_node: ::core::option::Option<Node>,
}
/// Node state enumeration
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
  Unspecified = 0,
  Alive = 1,
  Suspect = 2,
  Dead = 3,
}
impl State {
  /// String value of the enum field names used in the ProtoBuf definition.
  ///
  /// The values are not transformed in any way and thus are considered stable
  /// (if the ProtoBuf definition does not change) and safe for programmatic use.
  pub fn as_str_name(&self) -> &'static str {
    match self {
      Self::Unspecified => "UNSPECIFIED",
      Self::Alive => "ALIVE",
      Self::Suspect => "SUSPECT",
      Self::Dead => "DEAD",
    }
  }
  /// Creates an enum from field names used in the ProtoBuf definition.
  pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
    match value {
      "UNSPECIFIED" => Some(Self::Unspecified),
      "ALIVE" => Some(Self::Alive),
      "SUSPECT" => Some(Self::Suspect),
      "DEAD" => Some(Self::Dead),
      _ => None,
    }
  }
}
